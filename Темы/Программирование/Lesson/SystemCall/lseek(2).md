---
tags:
  - "#system_call"
---


**lseek(2)** - Это [[Linux. Системные вызовы|Системный вызов]] в Unix/Linux системах, который используется для манипуляцией позицией указателя (файлового смещения) в [[Дескриптор файлов|файловом дескрипторе]] открытого файла. Этот вызов позволяет перемещать указатель чтения/записи в любую позицию файла, что делает возможным произвольный доступ к данным.

```c
off_t pos=lseek(int fildes, off_t offset, int whence);
```
- **fildes** - файловый дескриптор открытого файла.
- **offset** - смещение в байтах.
- **whence** - точка отсчета для смещения:
	- **SEEK_SET (0)** - устанавливает позицию равной `offset` байтам от начала файла.
	- **SEEK_CUR (1)** - устанавливает позицию равной текущему положению плюс `offset` байтов.
	- **SEEK_END (2)** - устанавливает позицию равной размеру файла плюс `offset` байтов. Чаще всего используется для перемещения в конец файла (с нулевым файлом) или для определения размера файла.
	- **SEEK_DATA** - перемещает указатель к следующему расположению данных, большему или равному значению offset
	- **SEEK_HOLE** - перемещает указатель к следующему промежутку (отсутствию данных), большему или равному значению `offset`.
- **pos** - `lseek` возвращает текущую позицию относительно начала файла. Или -1 если произошла ошибка.

**Использование:**
- Переход в начало файла
```c
lseek(fd, 0, SEEK_SET);
```

- Добавление данных в конец файла
```c
lseek(fd, 0, SEEK_END);
write(fd, data, data_size);
```

- Создание разреженных файлов
```c
lseek(fd, 1024, SEEK_SET);  // Перемещение на 1024 байта от начала
write(fd, data, data_size);  // Запись данных с созданием "дыры"
```

- Определение размера файла
```c
off_t file_size = lseek(fd, 0, SEEK_END);
```

- Ну python
```python
import os

fd = os.open('example.txt', os.O_RDONLY)
os.lseek(fd, 0, os.SEEK_SET)
os.close(fd)
```

**Ограничения и специфика**
- [[Дескриптор файлов|файловый дескриптор]], созданный через [[dup(2)]] или **fork(2)**, разделяет указатель текущей позиции в файле. Если применить **lseek(2)** к таким файловым дескрипторам из разных потоков, то это может привести к состоянию гонок и неожиданному поведению. 
- **lseek** не работает с некоторыми типами файловых дескрипторов, такие как сокеты и каналы, которые не поддерживают концепцию позиционирования.

**Возможные ошибки**
- **EBADF**: Неверный файловый дескриптор.
- **EINVAL**:  Неверное значение whence или отрицательное смещение.
- **ENXIO**: Попытка использовать **SEEK_DATA** или **SEEK_HOLE** за пределами файла.
- **EOVERFLOW**: Результирующее смещение не может быть представлено в **off_t**.
- **ESPIPE**: Файловый дескриптор связан с **pipe**, **socket** или **FIFO**

**Обработка ошибок**
```c
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <errno.h>
#include <string.h>

void safe_seek(int fd, off_t offset, int whence) {
    off_t result = lseek(fd, offset, whence);
    if (result == -1) {
        switch (errno) {
            case EBADF:
                fprintf(stderr, "Ошибка: неверный дескриптор файла\n");
                break;
                
            case EINVAL:
                fprintf(stderr, "Ошибка: неверный параметр whence или недопустимая позиция\n");
                break;
                
            case ESPIPE:
                fprintf(stderr, "Ошибка: дескриптор ссылается на канал, сокет или FIFO\n");
                break;
                
            default:
                fprintf(stderr, "Ошибка lseek: %s\n", strerror(errno));
        }
        exit(1);
    }
}
```


**Примеры использования в проектах**

1. **Обработка больших файлов**
В проектах, связанных с обработкой больших файлов (Логов, Бинарных данных или баз данных), **lseek** используется для быстрого перемещения к нужной части файла без необходимости читать весь файл.  
	- **Чтение заголовков файлов:** Перемещение указателя в начало файла для чтения метаданных.
	- **Чтение блоков данных:** Перемещение к определенному блоку данных в бинарных файлах, таких как .db или .bin

```c
int fd = open("large_file.bin", O_RDONLY);
if (fd == -1) {
    perror("open");
    return -1;
}

// Перемещение к 1 МБ от начала файла
off_t offset = lseek(fd, 1024 * 1024, SEEK_SET);
if (offset == -1) {
    perror("lseek");
    close(fd);
    return -1;
}

// Чтение данных
char buffer[256];
read(fd, buffer, sizeof(buffer));
close(fd);
```

2. **Создание разреженных файлов (sparse files)**
Разреженные файлы используются для экономии дискового пространства. С помощью **lseek** можно пропустить большие области файла, не записывая данные, что создает "дыры" в файле.

```c
int fd = open("sparse_file.txt", O_WRONLY | O_CREAT, 0644);
if (fd == -1) {
    perror("open");
    return -1;
}

// Перемещение на 1 ГБ вперед
if (lseek(fd, 1024L * 1024 * 1024, SEEK_SET) == -1) {
    perror("lseek");
    close(fd);
    return -1;
}

// Запись данных в конец файла
write(fd, "END", 3);
close(fd);
```

3. **Реализация произвольного доступа в базах данных**
В базах данных, которые хранятся в виде файлов, **lseek** позволяет быстро находить и изменять записи. Например в простых файловых базах данных записи могут быть фиксированного размера, и **lseek** используется для перемещения к нужной записи

```c
int record_size = 128; // Размер одной записи
int record_number = 10; // Номер записи

// Перемещение к началу записи
off_t offset = lseek(fd, record_number * record_size, SEEK_SET);
if (offset == -1) {
    perror("lseek");
    return -1;
}

// Чтение записи
char record[record_size];
read(fd, record, record_size);
```

4. **Восстановление данных из поврежденных файлов.**
В проектах, связанных с восстановлением данных, **lseek** используется для пропуска поврежденных участков файлов и чтения только доступных данных.

5. **Оптимизация ввода-вывода**
В системах, где важна производительность, **lseek** позволяет минимизировать количество операций чтения/записи, перемещаясь только к нужным частям файла. Это особенно полезно в системах хранения данных и файловый системах.