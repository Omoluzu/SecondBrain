---
tags:
  - "#system_call"
---

Оглавление:
- [Работа с системными вызовами](#Работа%20с%20системными%20вызовами)


---
### Работа с системными вызовами

Руthon предоставляет несколько способов работы с [[Linux. Системные вызовы|системными вызовами]], использую стандартные модули, такие как `os`, `subprocess`, `posix`, а также специализированные модули для работы с низкоуровневыми функциями операционной системы.

---
### os

Модуль `os` предоставляет доступ к базовым системным вызовам, таким как работа с файлами, процессами и сигналами. 

Пример:
**Чтение и запись файла**
```python
import os
# Открытие файла
fd = os.open("example.txt", os.O_RDWR | os.O_CREAT)
# Запись в файл
os.write(fd, b"Hello, system calls!")
# Закрытие файла
os.close(fd)
```

**Создание процессов**
```python
pid = os.fork()
if pid == 0:
    print("Это дочерний процесс")
else:
    print(f"Это родительский процесс, PID дочернего: {pid}")
```

---
### subprocess

Модуль `subprocess` более высокоуровневый интерфейс, чем прямое использование системных вызовов.

```python
import subprocess
# Выполнение команды ls
result = subprocess.run(["ls", "-l"], capture_output=True, text=True)
# Вывод результата
print(result.stdout)
```

---
### posix

Модуль `posix` предоставляет доступ к системным вызовам, стандартизированным **POSIX**. Это низкоуровневый интерфейс, который позволяет напрямую вызывать функции операционной системы.

```python
import posix
# Получение текущего идентификатора процесса
pid = posix.getpid()
print(f"Текущий PID: {pid}")
```

Этот модуль полезен для работы с системами, совместимы с POSIX, такими как Linux и macOS.

---
### fcntl

Для работы с [[Дескриптор файлов|файловыми дескрипторами]] и управления ими можно использовать модуль `fcntl`. Он предоставляет доступ к системным вызовам `fcntl` и `ioctl`

```python
import fcntl
import os
# Открытие файла
fd = os.open("example.txt", os.O_RDWR | os.O_CREAT)
# Блокировка файла
fcntl.flock(fd, fcntl.LOCK_EX)
# Разблокировка файла
fcntl.flock(fd, fcntl.LOCK_UN)
os.close(fd)
```

Этот модуль полезен для управления ресурсами на уровне ядра.

---
### ctypes

Если нужно вызвать системный вызов напрямую, можно использовать модуль `ctypes` или `syscall` (в некоторых системах). Однако это требует знания номеров системных вызовов и их параметров.

```python
import ctypes
# Пример вызова write (номер системного вызова для Linux x86_64: 1)
libc = ctypes.CDLL(None)
libc.syscall(1, 1, b"Hello, syscall!\n", 15)
```

---
### Отслеживание системных вызовов

Для отладки системных вызовов можно использовать инструменты, такие как `strace`. 

```bash
strace -o trace.log python3 your_script.py
```

Это позволит увидеть какие системные вызовы выполнял наш скрипт.
