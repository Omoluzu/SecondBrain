---
tags:
  - "#profiling"
  - "#python/cProfile"
  - "#python/pstats"
aliases:
  - cProfile
---

**cProfile** - это мощный инструмент для профилирования Python-кода, который позволяет анализировать производительность программы, выявлять узкие места и оптимизировать выполнение. 

---

### Как использовать cProfile
##### Базовое профилирование.
```python
import cProfile

def my_function():
    total = 0
    for i in range(1000000):
        total += i
    return total

cProfile.run('my_function()')
```
##### Сохранение отчета в файл
```python
import cProfile

profiler = cProfile.Profile()
profiler.enable()
my_function()
profiler.disable()
profiler.dump_stats('profile_results.prof')
```
для анализа сохраненного кода используется модуль `pstats`
```python
import pstats

stats = pstats.Stats('profile_results.prof')
stats.sort_stats('cumulative').print_stats(10)  # Показать 10 самых затратных функций
```


### Описание параметров отчета cProfile
##### ncals
Количество вызовов функции. 
Так же может вместе одного числа быть данные в формате `{int_1}/{int_2}`
- **int_1** - Это общее кол-во вызовов функции. То есть функция была вызвана `int` раз.
- **int_2** - Это кол-во вызовов, которые были сделаны непосредственно из других функций

##### tottime
Общее время, затраченное на выполнение функции **без учета вызова других функций**. Это время, которое функция провела "сама по себе".

##### percall (tottime/ncals)
Среднее время выполнения функции за один вызов. Рассчитывается как [[#tottime]]/[[#ncals]]

##### cumtime
Общее время выполнения функции **включая вызовы других функций**. Полезно для анализа функций которые вызывают другие функции.

##### percall (cumtime/ncals)
Среднее время выполнения функции за один вызов, включая вызов других функций. Рассчитывается как [[#cumtime]]/[[#ncals]]

##### filename:lineno(function)
Имя файла: номер строки и имя функции, где происходил вызов.

### Как анализировать отчет.
- Ищите функции с большим значением [[#cumtime]]
	- Это функции которые занимают больше всего времени, включая вызовы других функций.
	- Они часто являются узким местом производительности.
- Обратите внимание на [[#tottime]]
	- Если функция имеет высокое значение [[#tottime]], это значит, что она сама по себе занимает много времени. 
	- Оптимизация этой функции может значительно ускорить выполнение программы.
- Сортировка данных.
	- Можно сортировать отчет по разным критериям для удобства анализа.
	```python
	stats.sort_stats('tottime').print_stats(10)  # Сортировка по времени выполнения функции
	stats.sort_stats('cumtime').print_stats(10)  # Сортировка по совокупному времени
	```
- Ищите мелкие функции с большим кол-вом вызовов
	- Если функция вызывается очень часто (высокое значение [[#ncals]]), даже небольшая оптимизация может дать значительный прирост производительности.