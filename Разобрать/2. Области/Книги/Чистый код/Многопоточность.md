Написать чистую многопоточную программу очень трудно.

#### Зачем нужна многопоточность ? 
Многопоточные программы можно рассматривать как стратегию устранения привязок. Оно помогает отделить выполняемую операцию от момента её выполнения.

#### Мифы и неверные представления.
- Многопоточность всегда повышает быстродействие.
- Написание многопоточного кода не изменяет архитектуру программы.
- При работе с контейнером разбираться в проблемах многопоточного программирования не обязательно
**Объективные утверждения относительно многопоточности**
- Многопоточность сопряжена с определенными дополнительными затратами - в отношении как производительности, так и написания дополнительного кода.
- Правильная реализация многопоточности сложна даже для простых задач
- Ошибки в многопоточном коде обычно не воспроизводятся, поэтому они часто игнорируются как случайные отклонения.
- Многопоточность часто требует фундаментальных изменений в стратегии проектирования.

#### Защита от ошибок многопоточности
##### Принцип единой ответственности.
метод/класс/компонент должен иметь только одну причину для изменений.
Разработчик должен учитывать ряд факторов.
- Код многопоточности должен иметь свой цикл разработки, модификации и настройки.
- При написания многопоточности возникают *специфические* сложности.
- Кол-во сбоев в неверно написанном многопоточном коде достаточно велико.  

> Отделяйте код, относящийся к реализации многопоточности, от остального кода.

##### Ограничивайте область видимости данных.
Защита критической секции кода, в которой происходят обращения к общему объекту, ключевым словом `synchronized`[^java]. 
Количество критических секций в коде должно быть сведено к минимуму.
Чем больше в программе мест обновляющие данные, тем больше вероятность: 
- Мы забудем защитить одно или несколько мест. Что приведет к нарушению работы всего кода.
- Может привести к дублирование усилий (Нарушению принципа [[DRY]])

[^java]: в Java

> Серьезно отнеситесь к [[инкапсуляция данных]], жестко ограничьте доступ ко всем общим данным.

##### Используйте копии данных
Для избегания нежелательных последствий одновременного доступа к данным, просто не используйте их.
Например: 
- можно скопировать общий объект и ограничить доступ к копии.
- результат работы нескольких программных потоков накапливаются в копиях, а затем объединяются в одном потоке.

##### Потоки должны быть как можно более независимыми.
Пишите многопоточный код так, чтобы каждый [[Поток]] существовал в замкнутом пространстве и не использовал данные совместно с другими процессами.
Каждый [[Поток]] должен обрабатывать один клиентский запрос, все его данные берутся из отдельного источника и хранятся в локальных переменных. В таком случае [[Поток]] работает так, словно других потоков не существует.

> Разбейте данные на независимые подмножества, с которыми могу работать независимые потоки.

#### Знайте свою библиотеку.

#### Модели выполнения.
Некоторые базовые определения.

| Наименование                    | Описание                                                                                                                              |
| ------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------- |
| Связанные ресурсы               | Ресурсы с фиксированным размером или кол-вом, существующие в многопоточной среде                                                      |
| Взаимное исключение             | В любой момент времени с общими данными или общим ресурсом может работать только один поток                                           |
| Зависание                       | Работа одного или нескольких потоков приостанавливаются на слишком долгое время (или навсегда)                                        |
| Взаимная блокировка (deadlock)  | Два и более потока бесконечно ожидают завершения друг друга.                                                                          |
| Обратимая блокировка (livelock) | Потоки не могут "Разойтись" - каждый из потоков пытается выполнять свою работу но обнаруживает, что другой поток стоит у него на пути |

##### Модель "производители потребители".
Один или несколько **потоков-производителей** создают *задания* и помещают их в буфер или очередь.

Один или несколько **потоков-потребителей** извлекают *задания* из очереди и выполняют их.

##### Модель "читатели-писатели".
Необходим если в системе имеется общий ресурс, который в основном служит источником информации для **потоков-читателей**, но время от времени обновляется **потоками-писателями**.  

Поиск баланса и предотвращения ошибок многопоточного обновления - основные проблемы этой модели выполнения.

#### Остерегайтесь зависимостей между синхронизированными методами.
Зависимости между синхронизированными методами приводят к появлению ошибок в многопоточном коде.

Если общий класс содержит более одного синхронизированного метода, ваша система спроектирована неверно.
> Избегайте использования нескольких методов одного совместно используемого объекта.

Однако без исключений не обойтись. Для обеспечения правильности работы в подобных ситуациях существуют три стандартных решения:
- *блокировка на стороне клиента* - клиент устанавливает блокировку для сервера перед вызовом первого метода, и следит за тем, чтобы блокировка распространялась на код, вызывающий последний метод.
- *блокировка на стороне сервера* - на стороне сервера создается метод, который блокирует сервер, вызывает все методы, после чего снимает блокировку. Этот новый метод называется клиентом.
- *адаптирующий сервер* - в системе создается посредник, который реализует блокировку. 

#### Синхронизированные секции должны иметь минимальный размер.
Блокировки обходятся дорого.

Следовательно, код не должен перегружаться лишними блокировками.

С другой стороны все критические секции[^krit] должны быть защищены.

Следовательно, код должен содержать как можно меньше критических секций.

> Синхронизированные секции в наших программах должны иметь минимальный размер.

[^krit]: **Критическая секция** - любой фрагмент кода, который должен быть защищен от одновременного использования несколькими программами.

#### Трудности корректного завершения.
Написание системы, которая должна работать бесконечно, отличается от написания системы, которая работает в течение некоторого времени ,а затем завершается.

Одна из проблем написания корректного завершения - взаимная блокировка [потоков](Поток.md). бесконечно долго ожидающих сигнала на продолжение работы.

#### Тестирование многопоточного кода.
Тестирование не гарантирует правильность работы кода. 

Тем не менее качественное тестирование сводит риск к минимуму. 

> [!info] Рекомендация 
> Пишите тесты, направленные на выявление существующих проблем. Если при выполнении теста происходит ошибка, обязательно найдите причину. Не игнорируйте ошибку только потому, то при следующем запуске тест был выполнен успешно.

- Рассматривайте непериодические сбои как признаки возможных проблем многопоточности.
- Начните с отладки основного кода, не связанного с многопоточностью.
- Реализуйте логическую изоляцию, конфигураций многопоточного кода.
- Обеспечьте возможность настройки многопоточного кода.
- Протестируйте программу с кол-вом потоков, превышающих кол-во [процессов](Процесс.md).
- Применяйте инструментовку (?) кода для повышения вероятности сбоев.

