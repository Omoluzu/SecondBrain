**[[Алгоритм]] Дейкстры** — это эффективный метод для нахождения кратчайших путей в [графах](Граф.md) с неотрицательными весами рёбер. Он был разработан нидерландским учёным Эдсгером Вибе Дейкстрой в 1959 году и широко используется в различных приложениях, таких как маршрутизация сетевых пакетов, навигационные системы и планирование движений в робототехнике.

Алгоритм Дейскстры работает только с *направленными ациклическими графами* **DAG (Directed Acyclic Graph)** 

> Использование алгоритма Дейустры с [графом](Граф.md), содержащим ребра с отрицательным весом, невозможно. Для этого используется [[Алгоритм Беллмана - Форда]]

### Основные принципы работы

Алгоритм Дейкстры решает задачу о кратчайших путях от одной заданной вершины (источника) до всех остальных вершин графа. Он работает по следующему алгоритмическому процессу:

1. **Инициализация**: Каждой вершине присваивается метка, которая представляет текущее известное расстояние от источника. Для начальной вершины метка равна 0, для всех остальных — бесконечность. Все вершины помечаются как непосещённые.
2. **Выбор минимальной метки**: На каждом шаге алгоритм выбирает непосещённую вершину с наименьшей меткой и помечает её как посещённую.
3. **Обновление меток соседей**: Для всех соседей текущей вершины проверяется, можно ли улучшить их метки. Если расстояние до соседа через текущую вершину меньше, чем ранее известное расстояние, то метка обновляется.
4. **Завершение**: Процесс продолжается до тех пор, пока все вершины не будут посещены или пока не будет достигнута целевая вершина (если задача состоит в нахождении кратчайшего пути только до одной вершины).


### Реализация:

```python
graph = {}
graph['start'] = {}
graph['start']['a'] = 6
graph['start']['b'] = 2
graph['a'] = {}
graph['a']['finish'] = 1
graph['b'] = {}
graph['b']['a'] = 3
graph['b']['finish'] = 1
graph['finish'] = {}

infinity = float("inf")
costs = {}
costs["a"] = 6
costs["b"] = 2
costs["finish"] = infinity

parents = {}
parents["a"] = "start"
parents["b"] = "start"
parents["finish"] = None

processed = []

def find_lowest_cost_node(costs):
	lowest_cost = float("inf")
	lowert_cost_node = None
	for node in costs:  # Перебрать все узлы
		cost = costs[node]
		if cost < lowest_cost and node not in procossed:  # Если это узел с наименьшей стоимостью из уже виденных и он еще не был обработан...
			lowest_cost = cost  #...он назначается новым узлом с наименьшей стоимостью.
			lowest_cost_node = node
	return lowest_cost_node


node = find_lowest_cost_node(costs)  # Найти узел с наименьшей стоимостью среди необработанных
while node is not None:  # Если обработаны все узлы, цикл завершен
	cost = costs[node]
	neighbors = graph[node]
	for n in neighbors.keys():  # Перебирать всех соседей текущего узла
		new_cost = cost + neighbors[n]
		if costs[n] > new_cost:  # Если к соседу можно быстрее добраться через текущий узел...
			costs[n] = new_cost  # ...обновить стоимость для этого узла
			parents[n] = node  # Этот узел становиться новым родителем для соседа
	processed.append(node)  # Узел пемечаеся как обработанный
	node = find_liwest_cist_node(costs)  # Найти следующий узел для обработки и повторить цикл.
```

### Применение

Алгоритм Дейкстры находит применение в различных областях:

- **Навигационные системы**: Определение оптимальных маршрутов для автомобилей и пешеходов.
- **Компьютерные сети**: Оптимизация маршрутов передачи данных для минимизации задержек.
- **Робототехника**: Планирование движения роботов с учётом препятствий.
- **Системы бронирования**: Поиск самых быстрых и дешевых маршрутов с учётом пересадок

## Ограничения

**Основное ограничение алгоритма** — невозможность работы с графами, содержащими рёбра с отрицательными весами. Это связано с тем, что такие веса могут привести к бесконечным циклам уменьшения длины пути. Также алгоритм может быть неэффективен для очень больших графов из-за своей временной сложности, которая в стандартной реализации составляет ==$O(n^2)$==, где n — количество вершин