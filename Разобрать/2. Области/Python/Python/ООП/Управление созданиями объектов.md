---
aliases: ООП, __init__, __new__, конструктор_классов
---

[Python Class Constructors: Control Your Object Instantiation – Real Python](https://realpython.com/python-class-constructor/)

## Управление созданием объектов.

Конструкторы классов являются фундаментальной частью объектно-ориентированного программирования в Python. Они позволяют нам создавать и правильно инициализировать объекты данного класса, делая эти объекты готовыми к использованию. Конструкторы классов внутренне запускают процесс создания экземпляра Python, который проходит через два основных этапа: создание экземпляра и инициализация экземпляра.

### Инициализация объекта с помощью \__init\__.
#### Предоставление пользовательских инициализаторов объекта.
Самая простая реализация `__init__()`, это просто позаботится о назначении входных аргументов соответствующих атрибутам экземпляра.
```python
class Rectangle:
	def __init__(self, width, height) -> None:
		self.width = width
		self.height = height
```
`__init__()` запускает второй этап процесса создания экземпляра объекта Python. Его первый аргумент, `self`, содержит новый экземпляр, полученный в результате вызова `__new__()`. Остальные аргументы `__init__()` обычно используются для инициализации атрибутов экземпляра.
> `__init__()` не должна явно возвращать ничего отличного от `None`, иначе получите исключение `TypeError:`

В `__init__()` можно делать любые преобразования вводных аргументов, чтобы правильно илициализировать атрибуты экземпляра.  	
Базованя реализация `__init__()` исходит из встроенного класса объектов. Эта реализация вызывается автоматически, если не предоставлен явный метод `__init__()` в создаваемых классах.

### Создание объектов с помощью \__new\__.
#### Создание пользовательских объектов.
Шаги по собственной реализации `__new__()`:
- Создание нового экземпляра, вызвав `super().__new__()` с соответствующими аргументами.
- Настройка нового экземпляра в соответствии с нашими потребностями.
- Вернуть новый экземпляр, для продолжения создания экземпляра.
```python
class SomeClass:
    def __new__(cls, *args, **kwargs):
        instance = super().__new__(cls)
        # Customize your instance here...
        return instance
```

#### Практические примеры.
##### Создание подкласов неизменяемых встроенных типов.
Написание класса Distance, как подклас типа `float`.
```python
class Distance(float):
	def __new__(cls, value, unit):
		instance = super().__new__(cls, value)
		instance.unit = unit
		return instance
```
class Distance работает позволяя нам использовать атрибут экземпляра для хранения единиц измерения, в котором измеряется расстояние.

##### Возврат экземпляра другого класса (Фабрика объектов).
```python
from random import choice

class Dog:
    def communicate(self):
        print("woof! woof!")

class Cat:
    def communicate(self):
        print("meow! meow!")

class Python:
    def communicate(self):
        print("hiss! hiss!")

class Pet:
    def __new__(cls):
        other = choice([Dog, Cat, Python])
        instance = super().__new__(other)
        print(f"I'm a {type(instance).__name__}!")
        return instance

    def __init__(self):
        print("Never runs!")

```
> При такой реализации пропускается инициализация текущего класса. 

##### Разрешение только одного экземпляра класса. (Singleton)
```python
class Singleton(object):  
    _instance = None  
    _initialized = False  
  
    def __new__(cls, *args, **kwargs):  
        if not cls._instance:  
            cls._instance = super().__new__(cls)  
        return cls._instance  
  
    def __init__(self, *args, **kwargs):  
        if self._initialized:  
            return  
        self._initialized = True
```



