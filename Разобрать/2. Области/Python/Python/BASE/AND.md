### AND

В Python есть три логических оператора, или логических операторов: `and`, `or`, and `not`. Вы можете использовать их, чтобы проверить, выполняются ли определенные условия, прежде чем решать, по какому пути будут следовать ваши программы. 

Оператор `and` принимает два операнда. которые могут быть логическими выражениями объектами или их комбинацией. Операндами в выражении `and` обычно называются условиями. Если оба условия верны, то выражение `and` возвращает истинный результат. В противном случае возвражается ложный результат 
```python
print(True and True)
>>> True
print(False and False)
>>> False
print(True and False)
>>> False
print(False and True)
>>> False
```

Таблица истинности операнда `and`:

operand1 | operand2 | operand1 and operand2
--- | --- | ---
`True` | `True` | `True`
`True` | `False` | `False`
`False` | `True` | `False`
`False` | `False` | `False`


###  Использование операнда `and` с логическими выражениями.
Синтаксис для создания составных логический выражений с оператором `and`:
```python
expression1 and expression2
```
Пример: 
```python
print(5 > 3 and 5 == 3 + 2)
>>> True
print(5 < 3 and 5 != 5)
>>> False
```
Если оба выражения `expression` равно `True`, то вернется `True`, если хотябы одно выражение равно `False`, то и вернется `False`

Нету ограничения на количество операндов `and`:
```python
print(5 > 3 and 5 == 3 + 2 and 5 != 3)
>>> True
```

### Ленивое вычисление

Python оценивает операнд справа только тогда когда это необходимо.  
Для определения окончательного результата выражения `and`, Python начинает c вычисления левого операнда. Если он ложный, то ложно и все выражение. В этом слечае нету необходимости оценивать второй операнд, так как результат уже ясен.

```python
def true_func():
	print("Running true_func()")
	return True
	
def false_func()
	print("Running false_func()")
	return False
	
print(true_func() and false_func())
>>> Running true_func()
>>> Running false_func()
>>> False

print(false_func() and true_func())
>>> Running false_func()
>>> False
```
Если есть необходимость в избежании `ленивых вычислений`, то это можно сделать с помощью побитовых операторов (`&`, `|`, `~`). Эти операторы также работают в логических выражениях, но они быстро оценивают операнды:
```python
# Использование логического and
false_func() and true_func()
>>> Running false_func()
>>> False

# Использование побитого and
false_func() & true_func()
>>> Running false_func()
>>> Running true_func()
>>> False
```
Несмотря на то что этот трюк работает, обычно его не рекомендуется использовать. Мы должны использовать побитовые операторы для управления битами а логические операторы для работы с логическими значениями. 
Про побитовые операторы читать [здесь](Bitwise.md).

### Использование оператора and с общими объектами.

Оператор `and` так же можно использовать для объединения двух объектов в одно выражение. В этом случае проверку `bool()` будет использоватся для определения истиности выражения. В результате мы будем получать конкретный объект, а не логическое значение. 

 object1 | object2 | object1 and object2
--- | --- | ---
`False` | `False` | *object1*
`False` | `True` | *object1*
`True` | `True` | *object2*
`True` | `False` | *object2*

Если значение первого выражения `False`, то возвращается первое выражение:
> Вспоминаем про [[#Ленивое вычисление]] Если первое выражение `False`, то операнд `and`. Не проверяет второе выражение.

Пример:
```python
print(2 and 3)
>>> 3
print(5 and 0.0)
>>> 0.0
print([] and 3)
>>> []
print(0 and {})
>>> 0
```

